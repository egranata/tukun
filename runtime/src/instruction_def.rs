// this file is autogenerated, do not edit manually
// to change this file consult gen/genall.sh
#[derive(Debug, Clone)]
pub enum InstructionDef {
    NOP,
    DUP,
    SWAP,
    POP,
    PUSH(u16),
    FLOOKUP,
    TLOOKUP,
    CALL,
    TYPEOF,
    FROMSLOT(u16),
    TOSLOT(u16),
    ADD,
    SUB,
    EQUAL,
    AND,
    OR,
    I2B,
    I2F,
    NOT,
    JUMP(crate::builder::BasicBlock),
    JTRUE(crate::builder::BasicBlock),
    RET,
    MKARRTYPE,
    MKRECTYPE,
    NEWARR,
    ARRGET,
    ARRSET,
    ARRLEN,
    NEWREC,
    RECGET,
    RECSET,
}
// this file is autogenerated, do not edit manually
// to change this file consult gen/genall.sh
impl InstructionDef {
    pub fn runtime_size(&self) -> usize {
        match self {
            InstructionDef::NOP => 1,
            InstructionDef::DUP => 1,
            InstructionDef::SWAP => 1,
            InstructionDef::POP => 1,
            InstructionDef::PUSH(_) => 1 + core::mem::size_of::<u16>(),
            InstructionDef::FLOOKUP => 1,
            InstructionDef::TLOOKUP => 1,
            InstructionDef::CALL => 1,
            InstructionDef::TYPEOF => 1,
            InstructionDef::FROMSLOT(_) => 1 + core::mem::size_of::<u16>(),
            InstructionDef::TOSLOT(_) => 1 + core::mem::size_of::<u16>(),
            InstructionDef::ADD => 1,
            InstructionDef::SUB => 1,
            InstructionDef::EQUAL => 1,
            InstructionDef::AND => 1,
            InstructionDef::OR => 1,
            InstructionDef::I2B => 1,
            InstructionDef::I2F => 1,
            InstructionDef::NOT => 1,
            InstructionDef::JUMP(_) => 1 + core::mem::size_of::<u16>(),
            InstructionDef::JTRUE(_) => 1 + core::mem::size_of::<u16>(),
            InstructionDef::RET => 1,
            InstructionDef::MKARRTYPE => 1,
            InstructionDef::MKRECTYPE => 1,
            InstructionDef::NEWARR => 1,
            InstructionDef::ARRGET => 1,
            InstructionDef::ARRSET => 1,
            InstructionDef::ARRLEN => 1,
            InstructionDef::NEWREC => 1,
            InstructionDef::RECGET => 1,
            InstructionDef::RECSET => 1,
        }
    }
}
// this file is autogenerated, do not edit manually
// to change this file consult gen/genall.sh
impl InstructionDef {
    pub fn is_terminal(&self) -> bool {
        match self {
            InstructionDef::NOP => false,
            InstructionDef::DUP => false,
            InstructionDef::SWAP => false,
            InstructionDef::POP => false,
            InstructionDef::PUSH(_) => false,
            InstructionDef::FLOOKUP => false,
            InstructionDef::TLOOKUP => false,
            InstructionDef::CALL => false,
            InstructionDef::TYPEOF => false,
            InstructionDef::FROMSLOT(_) => false,
            InstructionDef::TOSLOT(_) => false,
            InstructionDef::ADD => false,
            InstructionDef::SUB => false,
            InstructionDef::EQUAL => false,
            InstructionDef::AND => false,
            InstructionDef::OR => false,
            InstructionDef::I2B => false,
            InstructionDef::I2F => false,
            InstructionDef::NOT => false,
            InstructionDef::JUMP(_) => true,
            InstructionDef::JTRUE(_) => true,
            InstructionDef::RET => true,
            InstructionDef::MKARRTYPE => false,
            InstructionDef::MKRECTYPE => false,
            InstructionDef::NEWARR => false,
            InstructionDef::ARRGET => false,
            InstructionDef::ARRSET => false,
            InstructionDef::ARRLEN => false,
            InstructionDef::NEWREC => false,
            InstructionDef::RECGET => false,
            InstructionDef::RECSET => false,
        }
    }
}
// this file is autogenerated, do not edit manually
// to change this file consult gen/genall.sh
impl InstructionDef {
    pub fn write(&self, bc: &mut crate::bytecode::Bytecode) {
        match self {
            InstructionDef::NOP => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::NOP));
            }
            InstructionDef::DUP => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::DUP));
            }
            InstructionDef::SWAP => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::SWAP));
            }
            InstructionDef::POP => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::POP));
            }
            InstructionDef::PUSH(arg0) => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::PUSH));
                bc.write_u16(*arg0);
            }
            InstructionDef::FLOOKUP => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::FLOOKUP));
            }
            InstructionDef::TLOOKUP => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::TLOOKUP));
            }
            InstructionDef::CALL => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::CALL));
            }
            InstructionDef::TYPEOF => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::TYPEOF));
            }
            InstructionDef::FROMSLOT(arg0) => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::FROMSLOT));
                bc.write_u16(*arg0);
            }
            InstructionDef::TOSLOT(arg0) => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::TOSLOT));
                bc.write_u16(*arg0);
            }
            InstructionDef::ADD => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::ADD));
            }
            InstructionDef::SUB => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::SUB));
            }
            InstructionDef::EQUAL => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::EQUAL));
            }
            InstructionDef::AND => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::AND));
            }
            InstructionDef::OR => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::OR));
            }
            InstructionDef::I2B => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::I2B));
            }
            InstructionDef::I2F => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::I2F));
            }
            InstructionDef::NOT => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::NOT));
            }
            InstructionDef::JUMP(arg0) => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::JUMP));
                bc.write_u16(arg0.offset() as u16);
            }
            InstructionDef::JTRUE(arg0) => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::JTRUE));
                bc.write_u16(arg0.offset() as u16);
            }
            InstructionDef::RET => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::RET));
            }
            InstructionDef::MKARRTYPE => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::MKARRTYPE));
            }
            InstructionDef::MKRECTYPE => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::MKRECTYPE));
            }
            InstructionDef::NEWARR => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::NEWARR));
            }
            InstructionDef::ARRGET => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::ARRGET));
            }
            InstructionDef::ARRSET => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::ARRSET));
            }
            InstructionDef::ARRLEN => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::ARRLEN));
            }
            InstructionDef::NEWREC => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::NEWREC));
            }
            InstructionDef::RECGET => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::RECGET));
            }
            InstructionDef::RECSET => {
                bc.write_u8(u8::from(crate::opcodes::Opcode::RECSET));
            }
        }
    }
}
